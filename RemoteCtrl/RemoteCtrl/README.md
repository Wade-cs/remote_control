# 配置
属性-链接器-所有选项-入口点（mainCRTStartup） 子系统（窗口）
#pragma comment(linker, "/subsystem:windows /entry:mainCRTStartup")

# 单例模式 辅助类（如CHelper）
在C++中，对于单例模式的实现，使用一个辅助类（如CHelper）来确保单例对象的正确创建和销毁是一种常见做法，尤其是在涉及动态分配和资源管理时。下面解释为什么需要helper类来协助删除单例对象，而不是直接在对象不再需要时调用析构函数：
单例生命周期管理的挑战

    确保单例的唯一性:
    单例模式要求在整个应用程序中只有一个实例存在。这意味着构造函数必须是私有的，防止外部直接创建实例。

    正确地创建和销毁:
    创建单例实例通常发生在类的静态成员函数中（如getInstance()）。但如何确保在适当的时候销毁这个实例呢？

析构函数的限制

析构函数不能由程序员显式调用。它是当对象超出作用域或被显式删除时由编译器自动调用的。
在单例模式下，由于`单例对象通常是全局的或静态的，它的生命周期与程序的生命周期一致。`
这意味着如果没有特殊的机制，单例对象的析构函数将不会在程序正常终止之前被调用。
CHelper的作用

CHelper类的引入解决了上述问题。CHelper有一个构造函数和一个析构函数，它们分别在CHelper对象的创建和销毁时被调用。通过以下步骤，CHelper确保了单例对象的正确生命周期管理：

    创建单例:
        CHelper的构造函数中调用CServerSocket::getInstance()，这会创建或返回已存在的CServerSocket实例。

    销毁单例:
        当CHelper对象的生命周期结束（即，当程序退出时），其析构函数会被调用。
        析构函数中调用CServerSocket::releaseInstance()，这会释放CServerSocket的单例实例。

这种方法的优点是：

    自动管理:
    CHelper的生命周期与程序的生命周期自然同步，确保了单例的创建和销毁在正确的时间点进行。

    防止内存泄漏:
    即使程序员忘记显式调用释放函数，CHelper也会在程序退出时自动调用，避免了内存泄漏的风险。

    易于理解:
    这种模式清晰地表明了单例对象的生命周期管理策略，使得代码更加健壮和易于维护。

总结

使用CHelper类来管理单例对象的生命周期，是C++中一种优雅的解决方案，它确保了资源的正确释放，同时避免了析构函数不能显式调用带来的问题。这种方法尤其适用于那些需要在程序启动时初始化并在程序结束时清理的资源密集型对象，如数据库连接或网络套接字。